## Supplementary material {.page_break_before}

### Supplementary Note 1: Comparison with the Maximal Information Coefficient (MIC) on gene expression data {#sec:mic}

In our study, we compared various methods for finding relationships in data, including our method and MIC, a well-known technique that's great at uncovering complex patterns but requires a lot of computing power.
We tested MIC on a large set of gene expression data from the GTEx project, focusing on 5,000 genes that show a lot of variation.
This process took nearly five days to complete, which is significantly longer than the nine hours needed for our method, referred to as CCC.

Next, we analyzed how these methods distribute their findings, using the same approach as described in the main part of our paper.
The results, illustrated in one of our figures, show that CCC and MIC produce very similar patterns in this particular set of data, with the results essentially overlapping but slightly offset from each other.
Another figure demonstrates that the way CCC and MIC rate the relationships between pairs of genes is almost directly proportional and that both methods yield results that are comparable to those from traditional methods like Pearson and Spearman correlation.

![
**Distribution of MIC values on gene expression (GTEx v8, whole blood)  and comparison with other methods.**
**a)** Histogram of coefficient values.
**b)** Corresponding cumulative histogram. The dotted line maps the coefficient value that accumulates 70% of gene pairs.
**c)** 2D histogram plot with hexagonal bins between all coefficients, where a logarithmic scale was used to color each hexagon.
](images/coefs_comp/gtex_whole_blood/mic/dist-main.svg "Distribution of MIC values"){#fig:dist_coefs_mic width="100%"}



### Supplementary Note 2: Computational complexity of coefficients {#sec:time_test .page_break_before}

In our study, we also looked at how the CCC method stacks up against other methods in terms of how much computer power they need.
Even though CCC and another method called MIC can pick out similar pairs of genes from gene expression data, using MIC on big datasets can be really slow.
This slowness remains despite efforts to make it faster through various improvements.
The original way MIC worked was by using a complex technique that took a lot of computer power.
However, a newer, quicker version of MIC, known as MICe, has been introduced.
Both versions are available in a software package called `minepy`, which works with Python programming.

We tested these methods by seeing how long they took to analyze made-up data that mimics gene expression data with varying amounts of information.
Unlike the other methods, CCC has the advantage of letting us do calculations for each pair of genes separately and more quickly, especially when we use more than one computer processor at a time.
We checked how fast each method was by using both one and three processors.
The results, which are shown in a graph, illustrate the time each method took, with the times shown on a logarithmic scale to make it easier to compare them.

![
**Computational complexity of all correlation coefficients on simulated data.**
We simulated variables/features with varying data sizes (from 100 to a million, $x$-axis).
The plot shows the average time in seconds (log-scale) taken for each coefficient on ten repetitions (1000 repetitions were performed for data size 100).
CCC was run using 1 and 3 CPU cores.
MIC and MIC<sub>e</sub> did not finish running in a reasonable amount of time for data sizes of 10,000 and 100,000, respectively.
](images/coefs_comp/time_test/time_test-main.svg "Computation time"){#fig:time_test width="55%"}

In our study, we found that the Pearson and Spearman correlation methods were the quickest to calculate.
This is because they only require basic data summaries to work.
For instance, Pearson can work three times faster than the CCC method.
When looking at methods for finding non-linear relationships, CCC proved to be faster than both versions of MIC, except when dealing with very small datasets.
This speed difference is notable, especially considering that MIC was developed using C, a language known for its efficiency, while CCC was created with Python and made faster with the help of 'numba'.
When handling a dataset of one million entries, using CCC with multiple processing cores was twice as quick as using it with a single core.
This observation leads us to believe that by utilizing more advanced technology, like GPUs, we could improve CCC's speed to be more in line with Pearson's method.



### Tissue-specific gene networks with GIANT {.page_break_before}


| | **Interaction confidence** <!-- $colspan="7" -->    | | | | | | |
|:------:|:-----:|:-----:|:-----:|:--------:|:-----:|:-----:|:-----:|
| | **Blood** <!-- $colspan="3" --> | | | **Predicted cell type** <!-- $colspan="4" --> | | | |
| **Gene** |  **Min.** | **Avg.** | **Max.** |  **Cell type** | **Min.** | **Avg.** | **Max.** |
| *IFNG* | 0.19 | 0.42 | 0.54 | Natural killer cell<!-- $rowspan="2" --> | 0.74 | 0.90 | 0.99 |
| *SDS* | 0.18 | 0.29 | 0.41 | 0.65 | 0.81 | 0.94<!-- $removenext="2" --> |
| <!-- $colspan="7" --> |||||||
| *JUN* | 0.26 | 0.68 | 0.97 | Mononuclear phagocyte<!-- $rowspan="2" --> | 0.36 | 0.73 | 0.94 |
| *APOC1* | 0.22 | 0.47 | 0.77 | 0.29 | 0.50 | 0.80<!-- $removenext="2" --> |
| <!-- $colspan="7" --> |||||||
| *ZDHHC12* | 0.05 | 0.07 | 0.10 | Macrophage<!-- $rowspan="2" --> | 0.03 | 0.12 | 0.33 |
| *CCL18* | 0.74 | 0.79 | 0.86 | 0.36 | 0.70 | 0.90<!-- $removenext="2" --> |
| <!-- $colspan="7" --> |||||||
| *RASSF2* | 0.69 | 0.77 | 0.90 | Leukocyte<!-- $rowspan="2" --> | 0.66 | 0.74 | 0.88 |
| *CYTIP* | 0.74 | 0.85 | 0.91 | 0.76 | 0.84 | 0.91<!-- $removenext="2" --> |
| <!-- $colspan="7" --> |||||||
| *MYOZ1* | 0.09 | 0.17 | 0.37 | Skeletal muscle<!-- $rowspan="2" --> | 0.11 | 0.11 | 0.12 |
| *TNNI2* | 0.10 | 0.22 | 0.44 | 0.10 | 0.11 | 0.12<!-- $removenext="2" --> |
| <!-- $colspan="7" --> |||||||
| *PYGM* | 0.02 | 0.04 | 0.14 | Skeletal muscle<!-- $rowspan="2" --> | 0.01 | 0.02 | 0.04 |
| *TPM2* | 0.05 | 0.56 | 0.80 | 0.01 | 0.28 | 0.47<!-- $removenext="2" --> |

Table: Network statistics of six gene pairs shown in Figure @fig:upsetplot_coefs b for blood and predicted cell types.
Only gene pairs present in GIANT models are listed.
For each gene in the pair (first column), the minimum, average and maximum interaction coefficients with the other genes in the network are shown.
{#tbl:giant:weights}


<!-- ![
**Predicted tissue-specific networks from GIANT for six gene pairs prioritized by correlation coefficients.**
Gene pairs are from Figure @fig:upsetplot_coefs b.
A node represents a gene and an edge the probability that two genes are part of the same biological process in a specific cell type.
The cell type for each gene network was automatically predicted using [@doi:10.1101/gr.155697.113], and it is indicated at the top-right corner of each network.
A maximum of 15 genes are shown for each subfigure.
The GIANT web application automatically determined a minimum interaction confidence (edges' weights) to be shown.
All these analyses can be performed online using the following links:
*IFNG* - *SDS* [@url:https://hb.flatironinstitute.org/gene/10993+3458],
*JUN* - *APOC1* [@url:https://hb.flatironinstitute.org/gene/3725+341],
*ZDHHC12* - *CCL18* [@url:https://hb.flatironinstitute.org/gene/6362+84885],
*RASSF2* - *CYTIP* [@url:https://hb.flatironinstitute.org/gene/9770+9595],
*MYOZ1* - *TNNI2* [@url:https://hb.flatironinstitute.org/gene/58529+7136],
*PYGM* - *TPM2* [@url:https://hb.flatironinstitute.org/gene/5837+7169].
The GIANT web-server was accessed on April 4, 2022.
](images/coefs_comp/giant_networks/auto_selected_tissues/main.svg "GIANT network interaction"){#fig:giant_gene_pairs:pred_tissue width="100%"} -->
